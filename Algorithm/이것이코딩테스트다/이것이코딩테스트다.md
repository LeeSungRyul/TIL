# 1. 코딩테스트 개요

- Online Judge
  - [백준 온라인 저지](https://acmicpc.net)
  - [코드업](https://codeup.kr)
  - [프로그래머스](https://programmers.co.kr)
  - [SWEA](https://swexpertacademy.com)

# CH 3. 그리디

`현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘`

## 3.1 거스름돈

```
거스름돈으로 사용할 500원, 100원 50원, 10원짜리 동전이 무한히 존재할 때, 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라.
```

```python
# 가장 큰 화폐 단위부터 돈을 거슬러 주는 것
residue = int(input('거스름돈: '))

coins = [500, 100, 50, 10]
count = 0

for coin in coins:
    count += residue // c
    residue %= c
```

## 3.2 큰 수의 법칙

```
큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수는 없다.
```

```python
n, m, k = map(int, input().split(' '))
data = list(map(int, input().split(' ')))

data.sort(reverse = True)
max_first = data[0]
max_second = data[1]

count = int(m / k+1) * k
count += m % (k+1)

ans = 0
# max_first 값이 반복되는 횟수를 찾아서 for 사용을 자제
ans += count * max_first
ans += (m - count) * max_second

print(ans)
```

## 3.3 숫자 카드 게임

```
숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다
1. 숫자가 쓰인 카드들이 N X M 형태로 놓여 있다. 이 때, N은 행의 개수, M은 열의 개수이다.
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3. 그 다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑은 곳을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.
```

```python
n, m = map(int, input().split(' '))
data = []
for i in range(n):
  temp = list(map(int, input().split(' ')))
  data.append(temp)

ans = 0

for i in range(n):
  temp = min(data[i])
  if temp > ans:
    ans = temp

print(ans)
```

## 3.4 1이 될 때까지

```
어떠한 수 N이 1이 될 때까지 다음 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어 질 때만 선택할 수 있다.
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번 과정을 수행해야 하는 최소 횟수를 구하시오.
```

```python
n, k = map(int, input().split(' '))

ans = n % k
n -= ans
while n > 1:
  n //= k
  ans += 1
  
print(ans)
```

# CH 4. 구현

## 4.1 아이디어를 코드로 바꾸는 구현

- 상하좌우

```python
N = int(input())
directions = input().split(' ')
command = ['L', 'R', 'U', 'D']
# command에 맞춰 움직이는 방향까지 list 정의
dy = [-1 , 1, 0, 0]
dx = [0, 0, -1, 1]

current = [1, 1]

for direction in directions:
  for i in range(len(command)):
    if direction == command[i]:
      # temp 사용해서 continue 이용
      temp_x = current[0] + dx[i]
      temp_y = current[1] + dy[i]
      break
    
  if temp_x <= 0 or temp_y <= 0 or temp_x > N or temp_y > N:
    continue
    
  current[0] = temp_x
  current[1] = temp_y

print(current[0], current[1])
```

- 시각

```python
N = int(input())

count = 0
# 완전탐색
for i in range(N+1):
  for j in range(60):
    for k in range(60):
      if '3' in str(i)+str(j)+str(k):
        count += 1

print(count)
```

## 4.2 왕실의 나이트

```
왕실 정원은 8 X 8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서있다.
나이트는 말을 타고 있기 때문에 이동할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.
1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기
현재 나이트가 위치한 좌표가 문자열로 입력될 때 이동할 수 있는 경우의 수를 출력하시오.
```

```python
now = input()
direction = [i for i in range(8)]
dx = [2, 2, -2, -2, 1, 1, -1, -1]
dy = [1, -1, 1, -1, 2, -2, 2, -2]

cur_x = now[0]
cur_y = now[1]

count = 0

for i in range(len(direction)):
  next_y = int(cur_y) + dy[i]
  next_x = ord(cur_x) + dx[i]

  if next_y < 1 or next_y > 8 or next_x < ord('a') or next_x > ord('h'):
    continue
  
  count += 1

print(count)
```

## 4.3 게임 개발

```
캐릭터가 있는 장소는 1 X 1 크기의 정사각형으로 이뤄진 N X M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한 곳을 바라본다.
맵의 각 칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다.
캐릭터의 움직임을 설정하기 위해 정해 놓은 메뉴얼은 다음과 같다.
1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다.
2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유치한 채 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이 때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.
메뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하시오.
```

```python
first_input = input() # N X M 맵 생성
second_input = list(map(int, input().split(' ')))  # (x, y)에 북(0), 동(1), 남(2), 서(4)를 바라보는 캐릭터
size_x, size_y = map(int, first_input.split(' '))
now_x = int(second_input[0])
now_y = int(second_input[1])
now_dir = int(second_input[2])

total_map = {}

for i in range(size_y):
  line_input = list(map(int, input().split(' ')))
  for j in range(len(line_input)):
    total_map[f'{i}, {j}'] = line_input[j]

visited = []
visited.append((now_x, now_y))

dirs = [i for i in range(4)]
d_x = [-1, 0, 1, 0]
d_y = [0, 1, 0, -1]
# 4방향 탐색 여부 위해 turn_time 변수 활용
turn_time = 0

# 맵 상 범위 벗어나는 경우는 구현되지 않은 코드
while True:
  temp_idx = (dirs.index(now_dir) + 1) % 4
  next_dir = dirs[temp_idx]
  turn_time += 1
  next_x = now_x + d_x[temp_idx]
  next_y = now_y + d_y[temp_idx]

  # 회전 이후 가보지 않은 칸이 존재
  if (next_x, next_y) not in visited and total_map[f'{next_x}, {next_y}'] != 1:
    now_dir, now_x, now_y = next_dir, next_x, next_y
    visited.append((now_x, now_y))
    turn_time = 0
    continue
  # 회전 이후 가보지 않은 칸이 없거나 바다인 경우
  else:
    now_dir = next_dir
  
  # 4방향 모두 탐색한 경우
  if turn_time == 4:
    next_x = now_x - d_x[dirs.index(now_dir)]
    next_y = now_y - d_y[dirs.index(now_dir)]
    if total_map[f'{next_x}, {next_y}'] == 0:
      now_x = next_x
      now_y = next_y
      turn_time = 0
    else:
      break
  
print(len(visited))
```

# CH5. DFS / BFS

## 5.1 자료구조 기초

- 스택: FILO

- 큐: FIFO

  ```python
  import collections import deque
  
  queue = deque()
  
  queue.append(5)
  queue.popleft()
  queue.reverse()	# 큐 역순으로 바꾸기
  ```

- 재귀함수: 스택 자료구조 이용

## 5.2 DFS / BFS

- DFS

  `깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘`

  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드 꺼냄
  3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복

  ```python
  # 인접 행렬 방식
  INF = 999999999
  
  graph = [
      [0, 7, 5],
      [7, 0, INF],
      [5, INF, 0]
  ]
  ```

  ```python
  # 인접 리스트 방식
  graph = [[] for _ in range(3)]	# 행이 3개인 2차원 리스트로 인접 리스트 표현
  
  # 노드 0에 연결된 노드 정보 저장 (노드, 거리)
  graph[0].append((1, 7))
  graph[0].append((2, 5))
  
  # 노드 1에 연결된 노드 정보 저장 (노드, 거리)
  graph[1].append((0, 7))
  
  # 노드 2에 연결된 노드 정보 저장 (노드, 거리)
  graph[2].append((0, 5))
  ```

  ```python
  # DFS 메서드 정의
  def DFS(graph, v, visited):
      # 현재 노드를 방문 처리
      visited[v] = True
      print(v, end = ' ')
      # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
      for i in graph[v]:
          if not visited[i]:
              DFS(graph, i, visited)
  
  # 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
  graph = [
      [],
      [2, 3, 8],
      [1, 7],
      [1, 4, 5],
      [3, 5],
      [3, 4],
      [7],
      [2, 6, 8],
      [1, 7]
  ]
  
  # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
  visited = [False] * 9
  
  # 정의된 DFS 함수 호출
  DFS(graph, 1, visited)
  ```

  ```bash
  1 2 7 6 8 3 4 5
  ```

- BFS

  `너비 우선 탐색으로 가까운 노드부터 탐색하는 알고리즘. 큐 자료구조 이용`

  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
  3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복

  ```python
  from collections import deque
  
  # BFS 메서드 정의
  def BFS(graph, start, visited):
      # 큐 구현을 위해 deque 라이브러리 사용
      queue = deque([start])
      # 현재 노드 방문 처리
      visited[start] = True
      # 큐가 빌 때까지 반복
      while queue:
          # 큐에서 하나의 원소 뽑아 출력
          v = queue.popleft()
          print(v, end = ' ')
          # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
          for i in graph[v]:
              if not visited[i]:
                  queue.append(i)
                  visited[i] = True
            
  # 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
  graph = [
      [],
      [2, 3, 8],
      [1, 7],
      [1, 4, 5],
      [3, 5],
      [3, 4],
      [7],
      [2, 6, 8],
      [1, 7]
  ]
  
  # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
  visited = [False] * 9
  
  # 정의된 BFS 함수 호출
  BFS(graph, 1, visited)
  ```

  ```bash
  1 2 3 8 7 4 5 6
  ```

## 5.3 음료수 얼려 먹기

```
N X M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 잇는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이 때 얼음 틀의 모양이 주어질 때 생성되는 총 아이스크림의 개수를 구하시오.
예제)
00110
00011
11111
00000
출력: 3
```

```python
```



